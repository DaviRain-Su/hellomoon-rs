//! # Listing Status
//!
//! POST  `https://rest-api.hellomoon.io/v0/nft/listing-status`
//! Track and verify the NFT Listing Status by the NFT collection, NFT marketplace, or a single NFT.
//!
//! If the Listing Status is true, buyers can purchase the NFT at the asking price.
//! If the Listing Status is false, buyers have to place a bid on a marketplace for the NFT.
//!
//! Our supported NFT marketplaces are:
//!
//! SMB (Solana Monkey Business)
//! Solanart
//! MEv1 (Magic Eden v1)
//! MEv2 (Magic Eden v2)
//!
use std::default;

use crate::{core_call, limit_is_zero, page_is_zero};
use serde::{Deserialize, Serialize};

const LISTING_STATUS_API_URL: &str = "https://rest-api.hellomoon.io/v0/nft/listing-status";

#[derive(Debug, Serialize, Deserialize, PartialEq, Default)]
pub struct ListingStatusResponse {
    // /// array of objects
    data: Option<Vec<ListingStatus>>,
    /// The pagination token to use to keep your position in the results
    #[serde(rename = "paginationToken")]
    pagination_token: Option<String>,
}

#[derive(Debug, Serialize, Deserialize, PartialEq, Default)]
pub struct ListingStatus {
    /// To find the correct helloMoonCollectionId, click here and search a collection name. This list is continuously updated.
    #[serde(rename = "helloMoonCollectionId")]
    hello_moon_collection_id: Option<String>,
    /// Mint address of nft per the spl token program.
    /// Each NFT has a unique mint address within the collection.
    #[serde(rename = "nftMint")]
    nft_mint: Option<String>,
    /// A list of marketplaces and their data supported by HelloMoon
    /// MEv1 MEv2 SMB Solanart
    marketplace: Option<String>,
    /// Amount of a token unconverted for decimals, e.g. 1 SOL is 1,000,000,000 since SOL has 9 decimals.
    price: Option<usize>,
    /// the seller of the nft on the marketplace.
    seller: Option<String>,
    /// if the NFT is listed or not listed on the marketplace
    #[serde(rename = "isListed")]
    is_listed: Option<bool>,
    /// Unix epoch time (in seconds) of a block as calculated from validator votes.
    /// If you want to look at historical data, let's say 7 days in the past.
    /// 1. Change the operator to <
    /// 2. Get the current epochtime i.e, 1673831466 -> Jan 15, 2023
    /// 3. Subtract the current epochtime from ( 86400 * 7 ). Place the result of 1673831466 - ( 86400 * 7 ) = 1673226666 in the value input - this returns the epochtime time from 7 days ago
    #[serde(rename = "blockTime")]
    block_time: Option<String>,
    /// Numeric identifier of a block describing the slot that the block was produced in
    #[serde(rename = "blockId")]
    block_id: Option<String>,
    /// First signature in a transaction, which can be used to track and verify the transaction status across the complete ledger.
    /// It is a base-58 encoded string that is uniquely generated for each transaction.
    #[serde(rename = "transactionId")]
    transaction_id: Option<String>,
    /// Zero-indexed position of the transaction within the block
    #[serde(rename = "transactionPosition")]
    transaction_position: Option<usize>,
    /// The zero-indexed position of an instruction - subinstruction combination
    /// in the context of the transaction. This is generated by flattening
    /// all instruction/subinstruction/sub-subinstruction/... and numbering them from 0.
    #[serde(rename = "instructionOrdinal")]
    instruction_ordinal: Option<usize>,
}

#[derive(Debug, Serialize, Deserialize, PartialEq, Default)]
pub struct ListingStatusRequest {
    /// To find the correct helloMoonCollectionId,
    /// click here and search a collection name.
    /// This list is continuously updated.
    #[serde(rename = "helloMoonCollectionId")]
    #[serde(skip_serializing_if = "String::is_empty")]
    hello_moon_collection_id: String,
    /// Mint address of nft per the spl token program.
    /// Each NFT has a unique mint address within the collection.
    #[serde(rename = "nftMint")]
    #[serde(skip_serializing_if = "String::is_empty")]
    nft_mint: String,
    #[serde(rename = "isListed")]
    #[serde(skip_serializing_if = "Option::is_none")]
    is_listed: Option<bool>,
    /// A list of marketplaces and their data supported by HelloMoon
    #[serde(skip_serializing_if = "marketplace_is_empty")]
    marketplace: Option<Marketplace>,
    /// Amount of a token unconverted for decimals, e.g. 1 SOL is 1,000,000,000 since SOL has 9 decimals.
    #[serde(skip_serializing_if = "Option::is_none")]
    price: Option<usize>,
    /// Unix epoch time (in seconds) of a block as calculated from validator votes.
    /// If you want to look at historical data, let's say 7 days in the past.
    /// 1. Change the operator to <
    /// 2. Get the current epochtime i.e, 1673831466 -> Jan 15, 2023
    /// 3. Subtract the current epochtime from ( 86400 * 7 ). Place the result of 1673831466 - ( 86400 * 7 ) = 1673226666 in the value input - this returns the epochtime time from 7 days ago
    #[serde(skip_serializing_if = "Option::is_none")]
    block_time: Option<usize>,
    /// the seller of the nft on the marketplace.
    #[serde(skip_serializing_if = "String::is_empty")]
    seller: String,
    /// The number of results to return per page
    #[serde(skip_serializing_if = "limit_is_zero")]
    limit: usize,
    /// The page number to return
    #[serde(skip_serializing_if = "page_is_zero")]
    page: usize,
    /// The pagination token to use to keep your position in the results
    #[serde(rename = "paginationToken")]
    #[serde(skip_serializing_if = "String::is_empty")]
    pagination_token: String,
}

#[derive(Debug, Serialize, Deserialize, PartialEq, Default)]
pub enum Marketplace {
    #[serde(rename = "SMB")]
    Smb, // (Solana Monkey Business)
    #[serde(rename = "Solanart")]
    Solanart,
    #[default]
    #[serde(rename = "MEv1")]
    Mev1, //(Magic Eden v1)
    #[serde(rename = "MEv2")]
    Mev2, //(Magic Eden v2)
}

fn marketplace_is_empty(value: &Option<Marketplace>) -> bool {
    if let Some(v) = value {
        match serde_json::to_string(&v) {
            Ok(e) => e.is_empty(),
            Err(_) => true,
        }
    } else {
        true
    }
}

pub async fn listing_status(
    api_key: &str,
    request: Option<ListingStatusRequest>,
) -> anyhow::Result<ListingStatusResponse> {
    core_call::<ListingStatusRequest, ListingStatusResponse>(
        request,
        LISTING_STATUS_API_URL.to_string(),
        api_key,
    )
    .await
}

#[tokio::test]
#[ignore = "reason"]
async fn test_listing_status() {
    let mut request = ListingStatusRequest::default();
    request.hello_moon_collection_id = "040de757c0d2b75dcee999ddd47689c4".to_string();

    let api_key = dotenv::var("api_keys").unwrap();
    let left = listing_status(&api_key, Some(request)).await.unwrap();

    let r = serde_json::to_string_pretty(&left).unwrap();
    let right: ListingStatusResponse = serde_json::from_str(&r).unwrap();
    assert_eq!(left, right);
}
